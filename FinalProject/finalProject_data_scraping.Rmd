---
title: "Final Project Data Scraping"
author: "Nick Oliver"
output:
  prettydoc::html_pretty:
    theme: hpstr
    highlight: github
editor_options: 
  chunk_output_type: console
---

# Scraping Articles

The `rvest` library is part of the Tidyverse and specifically for scraping web data
```{r}
library(tidyverse)
```


We will start with the sitemap. Luckily it is a very simple page which just contains a very long list of links to article archives.
```{r}
siteMapUrl <- "https://www.wired.com/sitemap/"
siteMapHtml <- read_html(siteMapUrl)
```

To select the links to the archives I simply need to select the parent div which wraps the archive list then grab the `a` elements
```{r}
archiveLinkNodes <- siteMapHtml %>%
  html_nodes(".sitemap__section-archive > ul > li > a")
```

I end up with `r length(archiveLinkNodes)` archive links. Each archive contains multiple articles so to simplify the process and decrease the risk of being blocked I will randomly sample the archive list. 

I do want to make that I sample enough data because I want the articles to span a large  time span
```{r}
set.seed(1972)

sampledArchiveLinks <- sample(archiveLinkNodes, 150) %>%
  html_text()
```

Check the years to make sure we have a good sample. It appears the sample includes a link from every year that the Wired.com has published articles online which is an ideal result.
```{r}
sampledArchiveLinks %>%
  stringi::stri_extract_all_regex("(?<=year=)[0-9]+") %>%
  unlist() %>%
  unique() %>%
  parse_number() %>%
  sort()
```

Next I need to use the links to randomly select a subset of articles from the archive. Each link takes the user to another page with a list of articles that were published on the year, month and week listed in the link.

```{r}
links <- c()
for (archiveLink in sampledArchiveLinks[1:2]) {
  siteMapHtml <- read_html(archiveLink)
  archiveLinkNodes <- siteMapHtml %>% 
    html_nodes(".sitemap__section-archive > ul > li > a") %>%
    html_text()
  links <- c(links, archiveLinkNodes)
}
```

```{r}
html <- read_html(links[[1]])
```

```{r}
extractArticleContent <- function(html) {
  publishDate <- html %>%
  html_node(xpath = '//*[@data-testid="ContentHeaderPublishDate"]') %>% 
  html_text()


author <- html %>%
  html_node(xpath = '//*[@data-testid="BylineName"]') %>% 
  html_text()


subject <- html %>%
  html_node(xpath = '//*[@data-testid="ContentHeaderHed"]') %>% 
  html_text()


byLine <- html %>%
  html_node(xpath = '//*[@data-testid="ContentHeaderAccreditation"]/div') %>% 
  html_text()

category <- html %>% 
  html_nodes(".rubric__link") %>%
  html_text()

articleBody <- html %>% 
  html_node(".body__inner-container") %>% 
  html_text()

c(publishDate, author, subject, byLine, category, articleBody)
}
```


```{r}
# colNames <- c('publishDate', 'author', 'subject', 'byLine', 'category', 'body')
# articlesDf <- data.frame(matrix(ncol=length(colNames),nrow=0, dimnames=list(NULL, colNames)))
articlesDf <- data.frame(publishDate = character(), author = character(), subject = character(), byLine = character(), category = character(), body = character())
colnames(articlesDf) <- c('publishDate', 'author', 'subject', 'byLine', 'category', 'body')
data <- extractArticleContent(html)

articlesDf <- articlesDf %>% add_row(publishDate = data[1], author = data[2], subject = data[3], byLine = data[4], category = data[5], body = data[6])

```

Now that I have the data from a large amount of articles spanning a large time range, I will store that data in a database so it can be cleaned and analyzed



